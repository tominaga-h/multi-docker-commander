---
name: MDC ユニットテスト追加
overview: config, runner, logger パッケージのユニットテストを作成し、Makefile にテストコマンドを追加する。
todos:
  - id: fix-logger-bug
    content: logger.go の strings.TrimRight バグ修正
    status: cancelled
  - id: refactor-config-load
    content: config.go の Load を LoadFromDir に切り出してテスト可能にする
    status: completed
  - id: test-config
    content: internal/config/config_test.go を作成 (ExpandHome, validate, LoadFromDir)
    status: completed
  - id: test-runner
    content: internal/runner/runner_test.go を作成 (commandsForAction, validateProjectPath, newShellCommand, Run)
    status: completed
  - id: test-logger
    content: internal/logger/logger_test.go を作成 (Start, Success, Error, ProjectDone, Output)
    status: completed
  - id: test-integration
    content: test/integration/integration_test.go を作成 (YAML 設定ファイル経由の config→runner 結合テスト)
    status: completed
  - id: update-makefile
    content: Makefile に test, test-cover, test-integration ターゲットを追加
    status: completed
  - id: update-gitignore
    content: .gitignore に coverage.out を追加
    status: completed
isProject: false
---

# MDC ユニットテスト追加

## 対象パッケージと方針

### 1. `internal/config` (最もテストしやすい)

ファイル: `[internal/config/config_test.go](internal/config/config_test.go)` を新規作成

- `**ExpandHome**`: `~` 付きパス、`~` なしパス、空文字列
- `**Config.validate()**`: 正常系(parallel/sequential)、異常系(不正な execution_mode、空プロジェクト、name/path 未設定)
- `**Load**`: 一時ディレクトリに YAML ファイルを作成して読み込みテスト。`DefaultConfigDir` をバイパスするため、`Load` 関数をリファクタリングするか、ファイルシステムベースのテストを行う

`Load` は `DefaultConfigDir()` をハードコードで呼んでいるため、テスト用に内部で `LoadFromPath(path)` のようなヘルパーを切り出してエクスポートするか、テスト内で `os.UserHomeDir` ベースの一時設定を用意する。

**方針**: `LoadFromDir(configDir, name)` を切り出し、`Load` はそれを呼ぶラッパーとする。テストでは `LoadFromDir` を直接テストする。

### 2. `internal/runner` (部分的にテスト可能)

ファイル: `[internal/runner/runner_test.go](internal/runner/runner_test.go)` を新規作成

- `**commandsForAction`**: 非公開関数だが同パッケージ内のテストからアクセス可能。action="up"/"down"/不正値、commands 空のケース
- `**validateProjectPath`**: 一時ディレクトリ(存在する/しない/ファイル)で検証
- `**newShellCommand`**: cmd.Dir と cmd.Args の確認
- `**Run**` (統合テスト的): `echo` コマンドで sequential/parallel を簡易検証

### 3. `internal/logger` (出力キャプチャで検証)

ファイル: `[internal/logger/logger_test.go](internal/logger/logger_test.go)` を新規作成

- **各関数(Start, Success, Error, ProjectDone, Output)** の出力を `os.Pipe` でキャプチャして検証
- **バグ修正**: `[internal/logger/logger.go](internal/logger/logger.go)` 49行目

```go
// 現在 (バグ: 引数が3つ)
trimmed := strings.TrimRight(output, output, "\n")
// 修正後
trimmed := strings.TrimRight(output, "\n")
```

### 4. `test/integration/` (YAML 結合テスト)

ファイル: `[test/integration/integration_test.go](test/integration/integration_test.go)` を新規作成

テストシナリオ:

- **Sequential モード**: YAML 設定を一時ディレクトリに書き出し、`config.LoadFromDir` → `runner.Run` の一連の流れを検証。`touch marker.txt` のような副作用で実行を確認。
- **Parallel モード**: 複数プロジェクトの YAML を用意し、全プロジェクトのコマンドが実行されたことを検証。
- **エラー系**: 存在しないパスの YAML、不正な execution_mode の YAML など。

```go
// テストの骨格イメージ
func TestIntegration_SequentialUpDown(t *testing.T) {
    configDir := t.TempDir()
    projectDir := t.TempDir()

    yaml := fmt.Sprintf(`
execution_mode: sequential
projects:
  - name: svc
    path: %s
    commands:
      up: ["touch up.txt"]
      down: ["rm up.txt"]
`, projectDir)

    os.WriteFile(filepath.Join(configDir, "test.yml"), []byte(yaml), 0644)
    cfg, _ := config.LoadFromDir(configDir, "test")

    runner.Run(cfg, "up")
    // up.txt が存在することを検証

    runner.Run(cfg, "down")
    // up.txt が削除されたことを検証
}
```

### 5. Makefile 更新

`[Makefile](Makefile)` にテストコマンドを追加:

```makefile
test:
	go test ./internal/... -v

test-integration:
	go test ./test/... -v

test-all:
	go test ./... -v

test-cover:
	go test ./... -v -coverprofile=coverage.out
	go tool cover -func=coverage.out

build:
	go build -o mdc .
```

- `make test` -- ユニットテストのみ (internal/ 配下)
- `make test-integration` -- 結合テストのみ (test/ 配下)
- `make test-all` -- 全テスト
- `make test-cover` -- カバレッジ付き全テスト

## テスト設計の指針

- 標準ライブラリの `testing` パッケージのみ使用（外部テストフレームワークは追加しない）
- テーブル駆動テスト (table-driven tests) パターンを採用
- 一時ファイル/ディレクトリは `t.TempDir()` を使用
- `coverage.out` を `.gitignore` に追加

